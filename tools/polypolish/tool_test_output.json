{"version": "0.1", "tests": [{"id": "functional.test_toolbox.TestForTool_polypolish.test_tool_000000", "has_data": true, "data": {"tool_id": "polypolish", "tool_version": "0.5.0+galaxy0", "test_index": 0, "time_seconds": 23.526694536209106, "inputs": {"input|fasta_file": {"src": "hda", "id": "94b7233e3375b440"}, "input|raw_data_type|fastq_selector": "single", "input|raw_data_type|single_fastq": {"src": "hda", "id": "13f3e6c7ada83132"}}, "job": {"model_class": "Job", "id": "034916ff7c15e7b5", "state": "ok", "exit_code": 0, "update_time": "2022-09-08T14:21:10.025453", "create_time": "2022-09-08T14:20:59.873895", "galaxy_version": "22.05", "command_version": "Polypolish v0.5.0", "tool_id": "polypolish", "history_id": "966cf271c08eb8d8", "external_id": "120766", "command_line": "ln -s '/tmp/tmprjy9g23w/files/4/c/1/dataset_4c18679b-e4cc-425c-a0d8-887ebcb66563.dat' input_data &&  bwa index input_data && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/3/8/5/dataset_385e387d-41e5-4ead-b3e2-98a0a2760566.dat' > alignment.sam && polypolish input_data 'alignment.sam' > '/tmp/tmprjy9g23w/job_working_directory/000/45/outputs/galaxy_dataset_2e9f5658-1ddc-4e35-87ae-2ee906b48ac1.dat' --debug /tmp/tmprjy9g23w/job_working_directory/000/45/outputs/galaxy_dataset_4aed3d0e-f82c-4d03-9452-56deca60dba8.dat 2> '/tmp/tmprjy9g23w/job_working_directory/000/45/outputs/galaxy_dataset_f75369e0-c9d6-4347-a19f-0e2bcf9ea714.dat'", "traceback": null, "params": {"input": "{\"fasta_file\": {\"values\": [{\"id\": 48, \"src\": \"hda\"}]}, \"raw_data_type\": {\"__current_case__\": 0, \"fastq_selector\": \"single\", \"single_fastq\": {\"values\": [{\"id\": 50, \"src\": \"hda\"}]}}}", "options": "{\"debug\": \"true\", \"fraction_invalid\": \"0.2\", \"fraction_valid\": \"0.5\", \"max_errors\": \"10\", \"min_depth\": \"5\", \"no_logfile\": \"true\"}", "chromInfo": "\"/tmp/tmprjy9g23w/galaxy-dev/tool-data/shared/ucsc/chrom/?.len\"", "dbkey": "\"?\"", "__input_ext": "\"input\""}, "inputs": {"fasta_file": {"id": "94b7233e3375b440", "src": "hda", "uuid": "4c18679b-e4cc-425c-a0d8-887ebcb66563"}, "input|single_fastq": {"id": "be042cc817e5ea19", "src": "hda", "uuid": "385e387d-41e5-4ead-b3e2-98a0a2760566"}}, "outputs": {"polished_fasta": {"id": "5b71748e2ef7c9cc", "src": "hda", "uuid": "2e9f5658-1ddc-4e35-87ae-2ee906b48ac1"}, "debug_file": {"id": "4a728661fd378c6b", "src": "hda", "uuid": "4aed3d0e-f82c-4d03-9452-56deca60dba8"}, "logfile": {"id": "3315435ab2bfcd70", "src": "hda", "uuid": "f75369e0-c9d6-4347-a19f-0e2bcf9ea714"}}, "output_collections": {}, "tool_stdout": "", "tool_stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.021 sec; CPU: 0.007 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.541 CPU sec, 0.541 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/3/8/5/dataset_385e387d-41e5-4ead-b3e2-98a0a2760566.dat\n[main] Real time: 0.559 sec; CPU: 0.556 sec\n", "job_stdout": "", "job_stderr": "", "stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.021 sec; CPU: 0.007 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.541 CPU sec, 0.541 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/3/8/5/dataset_385e387d-41e5-4ead-b3e2-98a0a2760566.dat\n[main] Real time: 0.559 sec; CPU: 0.556 sec\n", "stdout": "", "job_messages": [], "dependencies": [], "user_email": "test@bx.psu.edu", "job_metrics": []}, "status": "success"}}, {"id": "functional.test_toolbox.TestForTool_polypolish.test_tool_000001", "has_data": true, "data": {"tool_id": "polypolish", "tool_version": "0.5.0+galaxy0", "test_index": 1, "time_seconds": 29.552919626235962, "inputs": {"input|fasta_file": {"src": "hda", "id": "e03525d85eaba9a4"}, "input|raw_data_type|R1_fastq": {"src": "hda", "id": "726d2bb1a54dc5f7"}, "input|raw_data_type|R2_fastq": {"src": "hda", "id": "b09301821c45de5c"}, "input|raw_data_type|fastq_selector": "paired", "options|debug": true, "options|no_logfile": false}, "job": {"model_class": "Job", "id": "5b71748e2ef7c9cc", "state": "ok", "exit_code": 0, "update_time": "2022-09-08T14:21:40.210722", "create_time": "2022-09-08T14:21:29.655229", "galaxy_version": "22.05", "command_version": "Polypolish v0.5.0", "tool_id": "polypolish", "history_id": "689a00278beb077e", "external_id": "121944", "command_line": "ln -s '/tmp/tmprjy9g23w/files/4/6/4/dataset_46466220-c6dd-4af6-a0b9-718429c35fbe.dat' input_data &&  bwa index input_data && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/8/3/8/dataset_838cb3e5-5be6-4d19-90dd-f7264bd0ac84.dat' > alignment_1.sam && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/d/6/0/dataset_d60ccc8e-32d7-40d8-af44-448f510f8413.dat' > alignment_2.sam && polypolish_insert_filter.py --low '0.1' --high '99.9' --in1 'alignment_1.sam' --in2 'alignment_2.sam' --out1 'filtered_1.sam' --out2 'filtered_2.sam' && polypolish input_data 'filtered_1.sam' 'filtered_2.sam' >  /tmp/tmprjy9g23w/job_working_directory/000/51/outputs/galaxy_dataset_ba6db7ca-d473-4908-b6c8-8a90e1f46399.dat --debug /tmp/tmprjy9g23w/job_working_directory/000/51/outputs/galaxy_dataset_761303c7-afa5-4f32-8b43-02d7ee9deeb9.dat", "traceback": null, "params": {"input": "{\"fasta_file\": {\"values\": [{\"id\": 54, \"src\": \"hda\"}]}, \"raw_data_type\": {\"R1_fastq\": {\"values\": [{\"id\": 57, \"src\": \"hda\"}]}, \"R2_fastq\": {\"values\": [{\"id\": 58, \"src\": \"hda\"}]}, \"__current_case__\": 1, \"fastq_selector\": \"paired\", \"insert_filter\": {\"__current_case__\": 0, \"filter_select\": \"filter\", \"high\": \"99.9\", \"low\": \"0.1\"}}}", "options": "{\"debug\": \"true\", \"fraction_invalid\": \"0.2\", \"fraction_valid\": \"0.5\", \"max_errors\": \"10\", \"min_depth\": \"5\", \"no_logfile\": \"false\"}", "chromInfo": "\"/tmp/tmprjy9g23w/galaxy-dev/tool-data/shared/ucsc/chrom/?.len\"", "dbkey": "\"?\"", "__input_ext": "\"input\""}, "inputs": {"fasta_file": {"id": "e03525d85eaba9a4", "src": "hda", "uuid": "46466220-c6dd-4af6-a0b9-718429c35fbe"}, "input|R1_fastq": {"id": "5c2028a274e76087", "src": "hda", "uuid": "838cb3e5-5be6-4d19-90dd-f7264bd0ac84"}, "input|R2_fastq": {"id": "e12ace16502e64f6", "src": "hda", "uuid": "d60ccc8e-32d7-40d8-af44-448f510f8413"}}, "outputs": {"polished_fasta": {"id": "f890170dec70ea15", "src": "hda", "uuid": "ba6db7ca-d473-4908-b6c8-8a90e1f46399"}, "debug_file": {"id": "1ed60a1a04e01ba8", "src": "hda", "uuid": "761303c7-afa5-4f32-8b43-02d7ee9deeb9"}}, "output_collections": {}, "tool_stdout": "", "tool_stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.020 sec; CPU: 0.007 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.513 CPU sec, 0.514 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/8/3/8/dataset_838cb3e5-5be6-4d19-90dd-f7264bd0ac84.dat\n[main] Real time: 0.531 sec; CPU: 0.527 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.481 CPU sec, 0.481 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/d/6/0/dataset_d60ccc8e-32d7-40d8-af44-448f510f8413.dat\n[main] Real time: 0.497 sec; CPU: 0.494 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  alignment_1.sam\n  alignment_2.sam\n\nOutput alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --orientation auto\n  --low 0.1\n  --high 99.9\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\nalignment_1.sam: 280 alignments from 275 reads\nalignment_2.sam: 272 alignments from 267 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 176 pairs\nrf: 74 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  30 (0.1st percentile)\nHigh threshold: 710 (99.9th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering alignment_1.sam:\n  4,989 pass\n  16 fail\n\nFiltering alignment_2.sam:\n  4,983 pass\n  22 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\nAlignments before filtering: 552\nAlignments after filtering:  9,972\n\nTime to run: 0:00:00.088728\n\n\n\u001b[1;4;93mStarting Polypolish\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\n\u001b[2m    Polypolish is a tool for polishing genome assemblies with short reads.\nUnlike other tools in this category, Polypolish uses SAM files where each read\nhas been aligned to all possible locations (not just a single best location).\nThis allows it to repair errors in repeat regions that other alignment-based\npolishers cannot fix.\u001b[0m\n\nPolypolish version: 0.5.0\n\nInput assembly:\n  input_data\n\nInput short-read alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --fraction_invalid 0.2\n  --fraction_valid 0.5\n  --max_errors 10\n  --min_depth 5\n  --debug /tmp/tmprjy9g23w/job_working_directory/000/51/outputs/galaxy_dataset_761303c7-afa5-4f32-8b43-02d7ee9deeb9.dat\n\n\n\u001b[1;4;93mLoading assembly\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\ncontig00001 (5,513 bp)\ncontig00002 (3,532 bp)\ncontig00003 (3,227 bp)\ncontig00004 (3,138 bp)\n\n\n\u001b[1;4;93mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\nfiltered_1.sam: 280 alignments from 275 reads\nfiltered_2.sam: 272 alignments from 267 reads\n\nFiltering for high-quality end-to-end alignments:\n  219 alignments kept\n  333 alignments discarded\n\n\n\u001b[1;4;93mPolishing assembly sequences\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\n\u001b[2m    For each position in the assembly, Polypolish determines the read depth\nat that position and collects all aligned bases. It then polishes the assembly\nby looking for positions where the pileup unambiguously supports a different\nsequence than the assembly.\u001b[0m\n\nPolishing contig00001 (5,513 bp):\n  mean read depth: 7.7x\n  170 bp have a depth of zero (96.9164% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00002 (3,532 bp):\n  mean read depth: 3.2x\n  941 bp have a depth of zero (73.3579% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00003 (3,227 bp):\n  mean read depth: 2.2x\n  785 bp have a depth of zero (75.6740% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00004 (3,138 bp):\n  mean read depth: 1.4x\n  1,239 bp have a depth of zero (60.5163% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\n\n\u001b[1;4;93mFinished!\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\nPolished sequence (to stdout):\n  contig00001_polypolish (5,513 bp)\n  contig00002_polypolish (3,532 bp)\n  contig00003_polypolish (3,227 bp)\n  contig00004_polypolish (3,138 bp)\n\nPer-base debugging info written to /tmp/tmprjy9g23w/job_working_directory/000/51/outputs/galaxy_dataset_761303c7-afa5-4f32-8b43-02d7ee9deeb9.dat\nTime to run: 0:00:00.037268\n\n", "job_stdout": "", "job_stderr": "", "stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.020 sec; CPU: 0.007 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.513 CPU sec, 0.514 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/8/3/8/dataset_838cb3e5-5be6-4d19-90dd-f7264bd0ac84.dat\n[main] Real time: 0.531 sec; CPU: 0.527 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.481 CPU sec, 0.481 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/d/6/0/dataset_d60ccc8e-32d7-40d8-af44-448f510f8413.dat\n[main] Real time: 0.497 sec; CPU: 0.494 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  alignment_1.sam\n  alignment_2.sam\n\nOutput alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --orientation auto\n  --low 0.1\n  --high 99.9\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\nalignment_1.sam: 280 alignments from 275 reads\nalignment_2.sam: 272 alignments from 267 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 176 pairs\nrf: 74 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  30 (0.1st percentile)\nHigh threshold: 710 (99.9th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering alignment_1.sam:\n  4,989 pass\n  16 fail\n\nFiltering alignment_2.sam:\n  4,983 pass\n  22 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\nAlignments before filtering: 552\nAlignments after filtering:  9,972\n\nTime to run: 0:00:00.088728\n\n\n\u001b[1;4;93mStarting Polypolish\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\n\u001b[2m    Polypolish is a tool for polishing genome assemblies with short reads.\nUnlike other tools in this category, Polypolish uses SAM files where each read\nhas been aligned to all possible locations (not just a single best location).\nThis allows it to repair errors in repeat regions that other alignment-based\npolishers cannot fix.\u001b[0m\n\nPolypolish version: 0.5.0\n\nInput assembly:\n  input_data\n\nInput short-read alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --fraction_invalid 0.2\n  --fraction_valid 0.5\n  --max_errors 10\n  --min_depth 5\n  --debug /tmp/tmprjy9g23w/job_working_directory/000/51/outputs/galaxy_dataset_761303c7-afa5-4f32-8b43-02d7ee9deeb9.dat\n\n\n\u001b[1;4;93mLoading assembly\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\ncontig00001 (5,513 bp)\ncontig00002 (3,532 bp)\ncontig00003 (3,227 bp)\ncontig00004 (3,138 bp)\n\n\n\u001b[1;4;93mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\nfiltered_1.sam: 280 alignments from 275 reads\nfiltered_2.sam: 272 alignments from 267 reads\n\nFiltering for high-quality end-to-end alignments:\n  219 alignments kept\n  333 alignments discarded\n\n\n\u001b[1;4;93mPolishing assembly sequences\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\n\u001b[2m    For each position in the assembly, Polypolish determines the read depth\nat that position and collects all aligned bases. It then polishes the assembly\nby looking for positions where the pileup unambiguously supports a different\nsequence than the assembly.\u001b[0m\n\nPolishing contig00001 (5,513 bp):\n  mean read depth: 7.7x\n  170 bp have a depth of zero (96.9164% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00002 (3,532 bp):\n  mean read depth: 3.2x\n  941 bp have a depth of zero (73.3579% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00003 (3,227 bp):\n  mean read depth: 2.2x\n  785 bp have a depth of zero (75.6740% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00004 (3,138 bp):\n  mean read depth: 1.4x\n  1,239 bp have a depth of zero (60.5163% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\n\n\u001b[1;4;93mFinished!\u001b[0m \u001b[2m(2022-09-08 14:21:36)\u001b[0m\nPolished sequence (to stdout):\n  contig00001_polypolish (5,513 bp)\n  contig00002_polypolish (3,532 bp)\n  contig00003_polypolish (3,227 bp)\n  contig00004_polypolish (3,138 bp)\n\nPer-base debugging info written to /tmp/tmprjy9g23w/job_working_directory/000/51/outputs/galaxy_dataset_761303c7-afa5-4f32-8b43-02d7ee9deeb9.dat\nTime to run: 0:00:00.037268\n\n", "stdout": "", "job_messages": [], "dependencies": [], "user_email": "test@bx.psu.edu", "job_metrics": []}, "status": "success"}}, {"id": "functional.test_toolbox.TestForTool_polypolish.test_tool_000002", "has_data": true, "data": {"tool_id": "polypolish", "tool_version": "0.5.0+galaxy0", "test_index": 2, "time_seconds": 28.057578086853027, "inputs": {"input|fasta_file": {"src": "hda", "id": "d686475f2d823281"}, "input|raw_data_type|fastq_selector": "multiple_single", "input|raw_data_type|single_collection": {"src": "hdca", "id": "be42a60b54b5fd6c"}, "options|debug": false, "options|no_logfile": true}, "job": {"model_class": "Job", "id": "b09301821c45de5c", "state": "ok", "exit_code": 0, "update_time": "2022-09-08T14:22:08.430074", "create_time": "2022-09-08T14:22:03.354854", "galaxy_version": "22.05", "command_version": "Polypolish v0.5.0", "tool_id": "polypolish", "history_id": "cd989da3f5c6e8b4", "external_id": "122594", "command_line": "ln -s '/tmp/tmprjy9g23w/files/0/6/4/dataset_0649bc96-d7ad-490d-9f0c-c999da3d79b9.dat' input_data &&  bwa index input_data && mkdir single_collection && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/2/9/f/dataset_29f56b41-e0b3-4ec3-9179-20aaad98014e.dat' > 'single_collection/R1.fastq.gz.sam' && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/1/3/7/dataset_1372e7b4-eaae-40ef-8e8e-5a72377a5fa6.dat' > 'single_collection/R1_bis.fastq.gz.sam' && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/8/1/f/dataset_81ff8cae-4320-4755-ad11-5e529ebb973b.dat' > 'single_collection/R1_ter.fastq.gz.sam' && polypolish input_data single_collection/*.sam > '/tmp/tmprjy9g23w/job_working_directory/000/56/outputs/galaxy_dataset_71c9dd65-2954-452d-a25c-5ebf79f50245.dat' 2> '/tmp/tmprjy9g23w/job_working_directory/000/56/outputs/galaxy_dataset_1ea18ee9-9c1a-4db7-883a-261399003f21.dat'", "traceback": null, "params": {"input": "{\"fasta_file\": {\"values\": [{\"id\": 61, \"src\": \"hda\"}]}, \"raw_data_type\": {\"__current_case__\": 2, \"fastq_selector\": \"multiple_single\", \"single_collection\": {\"values\": [{\"id\": 3, \"src\": \"hdca\"}]}}}", "options": "{\"debug\": \"false\", \"fraction_invalid\": \"0.2\", \"fraction_valid\": \"0.5\", \"max_errors\": \"10\", \"min_depth\": \"5\", \"no_logfile\": \"true\"}", "chromInfo": "\"/tmp/tmprjy9g23w/galaxy-dev/tool-data/shared/ucsc/chrom/?.len\"", "dbkey": "\"?\"", "__input_ext": "\"input\""}, "inputs": {"fasta_file": {"id": "d686475f2d823281", "src": "hda", "uuid": "0649bc96-d7ad-490d-9f0c-c999da3d79b9"}, "input|single_collection1": {"id": "ca400c3ead265ff1", "src": "hda", "uuid": "29f56b41-e0b3-4ec3-9179-20aaad98014e"}, "input|single_collection2": {"id": "d7c25c3d09adc4c3", "src": "hda", "uuid": "1372e7b4-eaae-40ef-8e8e-5a72377a5fa6"}, "input|single_collection3": {"id": "d045e71bb2a77a1c", "src": "hda", "uuid": "81ff8cae-4320-4755-ad11-5e529ebb973b"}}, "outputs": {"polished_fasta": {"id": "828beabb70adf048", "src": "hda", "uuid": "71c9dd65-2954-452d-a25c-5ebf79f50245"}, "logfile": {"id": "9be59902e0686e24", "src": "hda", "uuid": "1ea18ee9-9c1a-4db7-883a-261399003f21"}}, "output_collections": {}, "tool_stdout": "", "tool_stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.018 sec; CPU: 0.006 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.358 CPU sec, 0.358 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/2/9/f/dataset_29f56b41-e0b3-4ec3-9179-20aaad98014e.dat\n[main] Real time: 0.374 sec; CPU: 0.371 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.347 CPU sec, 0.347 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/1/3/7/dataset_1372e7b4-eaae-40ef-8e8e-5a72377a5fa6.dat\n[main] Real time: 0.361 sec; CPU: 0.358 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.351 CPU sec, 0.351 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/8/1/f/dataset_81ff8cae-4320-4755-ad11-5e529ebb973b.dat\n[main] Real time: 0.366 sec; CPU: 0.362 sec\n", "job_stdout": "", "job_stderr": "", "stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.018 sec; CPU: 0.006 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.358 CPU sec, 0.358 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/2/9/f/dataset_29f56b41-e0b3-4ec3-9179-20aaad98014e.dat\n[main] Real time: 0.374 sec; CPU: 0.371 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.347 CPU sec, 0.347 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/1/3/7/dataset_1372e7b4-eaae-40ef-8e8e-5a72377a5fa6.dat\n[main] Real time: 0.361 sec; CPU: 0.358 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.351 CPU sec, 0.351 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/8/1/f/dataset_81ff8cae-4320-4755-ad11-5e529ebb973b.dat\n[main] Real time: 0.366 sec; CPU: 0.362 sec\n", "stdout": "", "job_messages": [], "dependencies": [], "user_email": "test@bx.psu.edu", "job_metrics": []}, "status": "success"}}, {"id": "functional.test_toolbox.TestForTool_polypolish.test_tool_000003", "has_data": true, "data": {"tool_id": "polypolish", "tool_version": "0.5.0+galaxy0", "test_index": 3, "time_seconds": 39.80296611785889, "inputs": {"input|fasta_file": {"src": "hda", "id": "89e65dc1c9811474"}, "input|raw_data_type|fastq_selector": "multiple_paired", "input|raw_data_type|paired_collection": {"src": "hdca", "id": "7ec84d2667cf43a6"}}, "job": {"model_class": "Job", "id": "d045e71bb2a77a1c", "state": "ok", "exit_code": 0, "update_time": "2022-09-08T14:22:48.533008", "create_time": "2022-09-08T14:22:41.735889", "galaxy_version": "22.05", "command_version": "Polypolish v0.5.0", "tool_id": "polypolish", "history_id": "64f04d28c549b643", "external_id": "123189", "command_line": "ln -s '/tmp/tmprjy9g23w/files/c/2/9/dataset_c29e256e-7a1a-4bbc-9f87-fe45c0a65b21.dat' input_data &&  bwa index input_data && mkdir paired_collection && ln -s '/tmp/tmprjy9g23w/files/4/5/7/dataset_457e379a-a6f6-4083-9ce3-24c7f8493b54.dat' 'forward_input0.fastqsanger' && ln -s '/tmp/tmprjy9g23w/files/8/e/e/dataset_8ee38096-202d-4ca6-9ebe-6965c5834121.dat' 'reverse_input0.fastqsanger' && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/4/5/7/dataset_457e379a-a6f6-4083-9ce3-24c7f8493b54.dat' > 'paired_collection/forward_input0.fastqsanger.sam' && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/8/e/e/dataset_8ee38096-202d-4ca6-9ebe-6965c5834121.dat' > 'paired_collection/reverse_input0.fastqsanger.sam' && polypolish_insert_filter.py --low '0.1' --high '99.9' --in1 'paired_collection/forward_input0.fastqsanger.sam' --in2 'paired_collection/reverse_input0.fastqsanger.sam' --out1 'paired_collection/forward_input0.fastqsanger_filtered.sam' --out2 'paired_collection/reverse_input0.fastqsanger_filtered.sam' && ln -s '/tmp/tmprjy9g23w/files/3/d/a/dataset_3da9cd19-729f-47bc-ba12-dc6725bb083e.dat' 'forward_input1.fastqsanger' && ln -s '/tmp/tmprjy9g23w/files/7/e/5/dataset_7e52e666-e8e3-49ac-b66c-c35b47745ae2.dat' 'reverse_input1.fastqsanger' && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/3/d/a/dataset_3da9cd19-729f-47bc-ba12-dc6725bb083e.dat' > 'paired_collection/forward_input1.fastqsanger.sam' && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/7/e/5/dataset_7e52e666-e8e3-49ac-b66c-c35b47745ae2.dat' > 'paired_collection/reverse_input1.fastqsanger.sam' && polypolish_insert_filter.py --low '0.1' --high '99.9' --in1 'paired_collection/forward_input1.fastqsanger.sam' --in2 'paired_collection/reverse_input1.fastqsanger.sam' --out1 'paired_collection/forward_input1.fastqsanger_filtered.sam' --out2 'paired_collection/reverse_input1.fastqsanger_filtered.sam' && ln -s '/tmp/tmprjy9g23w/files/e/0/e/dataset_e0e9423c-728d-4212-a017-7dfe2a8d096e.dat' 'forward_input2.fastqsanger' && ln -s '/tmp/tmprjy9g23w/files/1/e/5/dataset_1e54026f-11f3-4c12-8af9-ef931f3726d1.dat' 'reverse_input2.fastqsanger' && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/e/0/e/dataset_e0e9423c-728d-4212-a017-7dfe2a8d096e.dat' > 'paired_collection/forward_input2.fastqsanger.sam' && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/1/e/5/dataset_1e54026f-11f3-4c12-8af9-ef931f3726d1.dat' > 'paired_collection/reverse_input2.fastqsanger.sam' && polypolish_insert_filter.py --low '0.1' --high '99.9' --in1 'paired_collection/forward_input2.fastqsanger.sam' --in2 'paired_collection/reverse_input2.fastqsanger.sam' --out1 'paired_collection/forward_input2.fastqsanger_filtered.sam' --out2 'paired_collection/reverse_input2.fastqsanger_filtered.sam' && polypolish input_data paired_collection/*_filtered.sam > '/tmp/tmprjy9g23w/job_working_directory/000/64/outputs/galaxy_dataset_09709a5a-41c3-4b89-9163-50888e2fe70e.dat' --debug /tmp/tmprjy9g23w/job_working_directory/000/64/outputs/galaxy_dataset_1e68f838-ef09-4d56-8b8c-18a7022c0815.dat 2> '/tmp/tmprjy9g23w/job_working_directory/000/64/outputs/galaxy_dataset_dd15adcd-c9d3-4ff7-83b3-a84e93a150f5.dat'", "traceback": null, "params": {"input": "{\"fasta_file\": {\"values\": [{\"id\": 67, \"src\": \"hda\"}]}, \"raw_data_type\": {\"__current_case__\": 3, \"fastq_selector\": \"multiple_paired\", \"insert_filter\": {\"__current_case__\": 0, \"filter_select\": \"filter\", \"high\": \"99.9\", \"low\": \"0.1\"}, \"paired_collection\": {\"values\": [{\"id\": 4, \"src\": \"hdca\"}]}}}", "options": "{\"debug\": \"true\", \"fraction_invalid\": \"0.2\", \"fraction_valid\": \"0.5\", \"max_errors\": \"10\", \"min_depth\": \"5\", \"no_logfile\": \"true\"}", "chromInfo": "\"/tmp/tmprjy9g23w/galaxy-dev/tool-data/shared/ucsc/chrom/?.len\"", "dbkey": "\"?\"", "__input_ext": "\"input\""}, "inputs": {"fasta_file": {"id": "89e65dc1c9811474", "src": "hda", "uuid": "c29e256e-7a1a-4bbc-9f87-fe45c0a65b21"}, "input|paired_collection1": {"id": "dc371791ec1a7279", "src": "hda", "uuid": "457e379a-a6f6-4083-9ce3-24c7f8493b54"}, "input|paired_collection2": {"id": "453869ba8189c3f6", "src": "hda", "uuid": "8ee38096-202d-4ca6-9ebe-6965c5834121"}, "input|paired_collection3": {"id": "f2d94afe858f4b76", "src": "hda", "uuid": "3da9cd19-729f-47bc-ba12-dc6725bb083e"}, "input|paired_collection4": {"id": "41ab9305946ec8e9", "src": "hda", "uuid": "7e52e666-e8e3-49ac-b66c-c35b47745ae2"}, "input|paired_collection5": {"id": "c94eea085bad4998", "src": "hda", "uuid": "e0e9423c-728d-4212-a017-7dfe2a8d096e"}, "input|paired_collection6": {"id": "e31d9832389b4b71", "src": "hda", "uuid": "1e54026f-11f3-4c12-8af9-ef931f3726d1"}}, "outputs": {"polished_fasta": {"id": "91b68ad96f83f5c9", "src": "hda", "uuid": "09709a5a-41c3-4b89-9163-50888e2fe70e"}, "debug_file": {"id": "9a7138b363a5f44a", "src": "hda", "uuid": "1e68f838-ef09-4d56-8b8c-18a7022c0815"}, "logfile": {"id": "a4d4402402eb735b", "src": "hda", "uuid": "dd15adcd-c9d3-4ff7-83b3-a84e93a150f5"}}, "output_collections": {}, "tool_stdout": "", "tool_stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.020 sec; CPU: 0.005 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.381 CPU sec, 0.381 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/4/5/7/dataset_457e379a-a6f6-4083-9ce3-24c7f8493b54.dat\n[main] Real time: 0.398 sec; CPU: 0.395 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.397 CPU sec, 0.397 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/8/e/e/dataset_8ee38096-202d-4ca6-9ebe-6965c5834121.dat\n[main] Real time: 0.413 sec; CPU: 0.410 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:22:43)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  paired_collection/forward_input0.fastqsanger.sam\n  paired_collection/reverse_input0.fastqsanger.sam\n\nOutput alignments:\n  paired_collection/forward_input0.fastqsanger_filtered.sam\n  paired_collection/reverse_input0.fastqsanger_filtered.sam\n\nSettings:\n  --orientation auto\n  --low 0.1\n  --high 99.9\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:22:43)\u001b[0m\npaired_collection/forward_input0.fastqsanger.sam: 280 alignments from 275 reads\npaired_collection/reverse_input0.fastqsanger.sam: 272 alignments from 267 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:22:43)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 176 pairs\nrf: 74 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  30 (0.1st percentile)\nHigh threshold: 710 (99.9th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:22:43)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering paired_collection/forward_input0.fastqsanger.sam:\n  4,989 pass\n  16 fail\n\nFiltering paired_collection/reverse_input0.fastqsanger.sam:\n  4,983 pass\n  22 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:22:43)\u001b[0m\nAlignments before filtering: 552\nAlignments after filtering:  9,972\n\nTime to run: 0:00:00.071405\n\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.379 CPU sec, 0.379 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/3/d/a/dataset_3da9cd19-729f-47bc-ba12-dc6725bb083e.dat\n[main] Real time: 0.395 sec; CPU: 0.391 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.354 CPU sec, 0.354 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/7/e/5/dataset_7e52e666-e8e3-49ac-b66c-c35b47745ae2.dat\n[main] Real time: 0.370 sec; CPU: 0.367 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:22:44)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  paired_collection/forward_input1.fastqsanger.sam\n  paired_collection/reverse_input1.fastqsanger.sam\n\nOutput alignments:\n  paired_collection/forward_input1.fastqsanger_filtered.sam\n  paired_collection/reverse_input1.fastqsanger_filtered.sam\n\nSettings:\n  --orientation auto\n  --low 0.1\n  --high 99.9\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:22:44)\u001b[0m\npaired_collection/forward_input1.fastqsanger.sam: 312 alignments from 303 reads\npaired_collection/reverse_input1.fastqsanger.sam: 300 alignments from 292 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:22:44)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 193 pairs\nrf: 79 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  30 (0.1st percentile)\nHigh threshold: 876 (99.9th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:22:44)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering paired_collection/forward_input1.fastqsanger.sam:\n  4,993 pass\n  16 fail\n\nFiltering paired_collection/reverse_input1.fastqsanger.sam:\n  4,985 pass\n  23 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:22:44)\u001b[0m\nAlignments before filtering: 612\nAlignments after filtering:  9,978\n\nTime to run: 0:00:00.065302\n\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.366 CPU sec, 0.366 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/e/0/e/dataset_e0e9423c-728d-4212-a017-7dfe2a8d096e.dat\n[main] Real time: 0.381 sec; CPU: 0.377 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.355 CPU sec, 0.355 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/1/e/5/dataset_1e54026f-11f3-4c12-8af9-ef931f3726d1.dat\n[main] Real time: 0.370 sec; CPU: 0.366 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:22:45)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  paired_collection/forward_input2.fastqsanger.sam\n  paired_collection/reverse_input2.fastqsanger.sam\n\nOutput alignments:\n  paired_collection/forward_input2.fastqsanger_filtered.sam\n  paired_collection/reverse_input2.fastqsanger_filtered.sam\n\nSettings:\n  --orientation auto\n  --low 0.1\n  --high 99.9\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:22:45)\u001b[0m\npaired_collection/forward_input2.fastqsanger.sam: 305 alignments from 299 reads\npaired_collection/reverse_input2.fastqsanger.sam: 300 alignments from 294 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:22:45)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 195 pairs\nrf: 76 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  30 (0.1st percentile)\nHigh threshold: 533 (99.9th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:22:45)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering paired_collection/forward_input2.fastqsanger.sam:\n  4,988 pass\n  18 fail\n\nFiltering paired_collection/reverse_input2.fastqsanger.sam:\n  4,982 pass\n  24 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:22:45)\u001b[0m\nAlignments before filtering: 605\nAlignments after filtering:  9,970\n\nTime to run: 0:00:00.065743\n\n", "job_stdout": "", "job_stderr": "", "stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.020 sec; CPU: 0.005 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.381 CPU sec, 0.381 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/4/5/7/dataset_457e379a-a6f6-4083-9ce3-24c7f8493b54.dat\n[main] Real time: 0.398 sec; CPU: 0.395 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.397 CPU sec, 0.397 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/8/e/e/dataset_8ee38096-202d-4ca6-9ebe-6965c5834121.dat\n[main] Real time: 0.413 sec; CPU: 0.410 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:22:43)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  paired_collection/forward_input0.fastqsanger.sam\n  paired_collection/reverse_input0.fastqsanger.sam\n\nOutput alignments:\n  paired_collection/forward_input0.fastqsanger_filtered.sam\n  paired_collection/reverse_input0.fastqsanger_filtered.sam\n\nSettings:\n  --orientation auto\n  --low 0.1\n  --high 99.9\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:22:43)\u001b[0m\npaired_collection/forward_input0.fastqsanger.sam: 280 alignments from 275 reads\npaired_collection/reverse_input0.fastqsanger.sam: 272 alignments from 267 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:22:43)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 176 pairs\nrf: 74 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  30 (0.1st percentile)\nHigh threshold: 710 (99.9th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:22:43)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering paired_collection/forward_input0.fastqsanger.sam:\n  4,989 pass\n  16 fail\n\nFiltering paired_collection/reverse_input0.fastqsanger.sam:\n  4,983 pass\n  22 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:22:43)\u001b[0m\nAlignments before filtering: 552\nAlignments after filtering:  9,972\n\nTime to run: 0:00:00.071405\n\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.379 CPU sec, 0.379 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/3/d/a/dataset_3da9cd19-729f-47bc-ba12-dc6725bb083e.dat\n[main] Real time: 0.395 sec; CPU: 0.391 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.354 CPU sec, 0.354 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/7/e/5/dataset_7e52e666-e8e3-49ac-b66c-c35b47745ae2.dat\n[main] Real time: 0.370 sec; CPU: 0.367 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:22:44)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  paired_collection/forward_input1.fastqsanger.sam\n  paired_collection/reverse_input1.fastqsanger.sam\n\nOutput alignments:\n  paired_collection/forward_input1.fastqsanger_filtered.sam\n  paired_collection/reverse_input1.fastqsanger_filtered.sam\n\nSettings:\n  --orientation auto\n  --low 0.1\n  --high 99.9\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:22:44)\u001b[0m\npaired_collection/forward_input1.fastqsanger.sam: 312 alignments from 303 reads\npaired_collection/reverse_input1.fastqsanger.sam: 300 alignments from 292 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:22:44)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 193 pairs\nrf: 79 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  30 (0.1st percentile)\nHigh threshold: 876 (99.9th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:22:44)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering paired_collection/forward_input1.fastqsanger.sam:\n  4,993 pass\n  16 fail\n\nFiltering paired_collection/reverse_input1.fastqsanger.sam:\n  4,985 pass\n  23 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:22:44)\u001b[0m\nAlignments before filtering: 612\nAlignments after filtering:  9,978\n\nTime to run: 0:00:00.065302\n\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.366 CPU sec, 0.366 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/e/0/e/dataset_e0e9423c-728d-4212-a017-7dfe2a8d096e.dat\n[main] Real time: 0.381 sec; CPU: 0.377 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.355 CPU sec, 0.355 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/1/e/5/dataset_1e54026f-11f3-4c12-8af9-ef931f3726d1.dat\n[main] Real time: 0.370 sec; CPU: 0.366 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:22:45)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  paired_collection/forward_input2.fastqsanger.sam\n  paired_collection/reverse_input2.fastqsanger.sam\n\nOutput alignments:\n  paired_collection/forward_input2.fastqsanger_filtered.sam\n  paired_collection/reverse_input2.fastqsanger_filtered.sam\n\nSettings:\n  --orientation auto\n  --low 0.1\n  --high 99.9\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:22:45)\u001b[0m\npaired_collection/forward_input2.fastqsanger.sam: 305 alignments from 299 reads\npaired_collection/reverse_input2.fastqsanger.sam: 300 alignments from 294 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:22:45)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 195 pairs\nrf: 76 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  30 (0.1st percentile)\nHigh threshold: 533 (99.9th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:22:45)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering paired_collection/forward_input2.fastqsanger.sam:\n  4,988 pass\n  18 fail\n\nFiltering paired_collection/reverse_input2.fastqsanger.sam:\n  4,982 pass\n  24 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:22:45)\u001b[0m\nAlignments before filtering: 605\nAlignments after filtering:  9,970\n\nTime to run: 0:00:00.065743\n\n", "stdout": "", "job_messages": [], "dependencies": [], "user_email": "test@bx.psu.edu", "job_metrics": []}, "status": "success"}}, {"id": "functional.test_toolbox.TestForTool_polypolish.test_tool_000004", "has_data": true, "data": {"tool_id": "polypolish", "tool_version": "0.5.0+galaxy0", "test_index": 4, "time_seconds": 22.714003324508667, "inputs": {"input|fasta_file": {"src": "hda", "id": "d317e1e73246acfe"}, "input|raw_data_type|R1_fastq": {"src": "hda", "id": "ed98ef50d04e95d5"}, "input|raw_data_type|R2_fastq": {"src": "hda", "id": "49865c75ad2c7cb6"}, "input|raw_data_type|fastq_selector": "paired", "options|debug": false, "options|no_logfile": false}, "job": {"model_class": "Job", "id": "f2d94afe858f4b76", "state": "ok", "exit_code": 0, "update_time": "2022-09-08T14:23:11.416532", "create_time": "2022-09-08T14:23:03.265489", "galaxy_version": "22.05", "command_version": "Polypolish v0.5.0", "tool_id": "polypolish", "history_id": "fc85e2b5ae3a1926", "external_id": "123699", "command_line": "ln -s '/tmp/tmprjy9g23w/files/c/3/5/dataset_c350c0b6-c958-4c5c-a44f-8d9909b6a301.dat' input_data &&  bwa index input_data && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/a/e/0/dataset_ae00f03e-2f89-4593-8086-5ee91a9f8dd9.dat' > alignment_1.sam && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/a/6/f/dataset_a6f5eb4c-9d2e-4fc1-b244-a1199fec650e.dat' > alignment_2.sam && polypolish_insert_filter.py --low '0.1' --high '99.9' --in1 'alignment_1.sam' --in2 'alignment_2.sam' --out1 'filtered_1.sam' --out2 'filtered_2.sam' && polypolish input_data 'filtered_1.sam' 'filtered_2.sam' >  /tmp/tmprjy9g23w/job_working_directory/000/70/outputs/galaxy_dataset_a4d93741-7c0b-4781-a41a-5dc97f7b5189.dat", "traceback": null, "params": {"input": "{\"fasta_file\": {\"values\": [{\"id\": 77, \"src\": \"hda\"}]}, \"raw_data_type\": {\"R1_fastq\": {\"values\": [{\"id\": 80, \"src\": \"hda\"}]}, \"R2_fastq\": {\"values\": [{\"id\": 81, \"src\": \"hda\"}]}, \"__current_case__\": 1, \"fastq_selector\": \"paired\", \"insert_filter\": {\"__current_case__\": 0, \"filter_select\": \"filter\", \"high\": \"99.9\", \"low\": \"0.1\"}}}", "options": "{\"debug\": \"false\", \"fraction_invalid\": \"0.2\", \"fraction_valid\": \"0.5\", \"max_errors\": \"10\", \"min_depth\": \"5\", \"no_logfile\": \"false\"}", "chromInfo": "\"/tmp/tmprjy9g23w/galaxy-dev/tool-data/shared/ucsc/chrom/?.len\"", "dbkey": "\"?\"", "__input_ext": "\"input\""}, "inputs": {"fasta_file": {"id": "d317e1e73246acfe", "src": "hda", "uuid": "c350c0b6-c958-4c5c-a44f-8d9909b6a301"}, "input|R1_fastq": {"id": "53d9e308203118b3", "src": "hda", "uuid": "ae00f03e-2f89-4593-8086-5ee91a9f8dd9"}, "input|R2_fastq": {"id": "0be6068e54231cbe", "src": "hda", "uuid": "a6f5eb4c-9d2e-4fc1-b244-a1199fec650e"}}, "outputs": {"polished_fasta": {"id": "a1bcce9ecdd2e452", "src": "hda", "uuid": "a4d93741-7c0b-4781-a41a-5dc97f7b5189"}}, "output_collections": {}, "tool_stdout": "", "tool_stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.018 sec; CPU: 0.005 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.354 CPU sec, 0.354 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/a/e/0/dataset_ae00f03e-2f89-4593-8086-5ee91a9f8dd9.dat\n[main] Real time: 0.370 sec; CPU: 0.367 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.350 CPU sec, 0.349 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/a/6/f/dataset_a6f5eb4c-9d2e-4fc1-b244-a1199fec650e.dat\n[main] Real time: 0.365 sec; CPU: 0.363 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  alignment_1.sam\n  alignment_2.sam\n\nOutput alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --orientation auto\n  --low 0.1\n  --high 99.9\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\nalignment_1.sam: 280 alignments from 275 reads\nalignment_2.sam: 272 alignments from 267 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 176 pairs\nrf: 74 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  30 (0.1st percentile)\nHigh threshold: 710 (99.9th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering alignment_1.sam:\n  4,989 pass\n  16 fail\n\nFiltering alignment_2.sam:\n  4,983 pass\n  22 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\nAlignments before filtering: 552\nAlignments after filtering:  9,972\n\nTime to run: 0:00:00.067202\n\n\n\u001b[1;4;93mStarting Polypolish\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\n\u001b[2m    Polypolish is a tool for polishing genome assemblies with short reads.\nUnlike other tools in this category, Polypolish uses SAM files where each read\nhas been aligned to all possible locations (not just a single best location).\nThis allows it to repair errors in repeat regions that other alignment-based\npolishers cannot fix.\u001b[0m\n\nPolypolish version: 0.5.0\n\nInput assembly:\n  input_data\n\nInput short-read alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --fraction_invalid 0.2\n  --fraction_valid 0.5\n  --max_errors 10\n  --min_depth 5\n  not logging debugging information\n\n\n\u001b[1;4;93mLoading assembly\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\ncontig00001 (5,513 bp)\ncontig00002 (3,532 bp)\ncontig00003 (3,227 bp)\ncontig00004 (3,138 bp)\n\n\n\u001b[1;4;93mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\nfiltered_1.sam: 280 alignments from 275 reads\nfiltered_2.sam: 272 alignments from 267 reads\n\nFiltering for high-quality end-to-end alignments:\n  219 alignments kept\n  333 alignments discarded\n\n\n\u001b[1;4;93mPolishing assembly sequences\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\n\u001b[2m    For each position in the assembly, Polypolish determines the read depth\nat that position and collects all aligned bases. It then polishes the assembly\nby looking for positions where the pileup unambiguously supports a different\nsequence than the assembly.\u001b[0m\n\nPolishing contig00001 (5,513 bp):\n  mean read depth: 7.7x\n  170 bp have a depth of zero (96.9164% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00002 (3,532 bp):\n  mean read depth: 3.2x\n  941 bp have a depth of zero (73.3579% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00003 (3,227 bp):\n  mean read depth: 2.2x\n  785 bp have a depth of zero (75.6740% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00004 (3,138 bp):\n  mean read depth: 1.4x\n  1,239 bp have a depth of zero (60.5163% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\n\n\u001b[1;4;93mFinished!\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\nPolished sequence (to stdout):\n  contig00001_polypolish (5,513 bp)\n  contig00002_polypolish (3,532 bp)\n  contig00003_polypolish (3,227 bp)\n  contig00004_polypolish (3,138 bp)\n\nTime to run: 0:00:00.010772\n\n", "job_stdout": "", "job_stderr": "", "stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.018 sec; CPU: 0.005 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.354 CPU sec, 0.354 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/a/e/0/dataset_ae00f03e-2f89-4593-8086-5ee91a9f8dd9.dat\n[main] Real time: 0.370 sec; CPU: 0.367 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.350 CPU sec, 0.349 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/a/6/f/dataset_a6f5eb4c-9d2e-4fc1-b244-a1199fec650e.dat\n[main] Real time: 0.365 sec; CPU: 0.363 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  alignment_1.sam\n  alignment_2.sam\n\nOutput alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --orientation auto\n  --low 0.1\n  --high 99.9\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\nalignment_1.sam: 280 alignments from 275 reads\nalignment_2.sam: 272 alignments from 267 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 176 pairs\nrf: 74 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  30 (0.1st percentile)\nHigh threshold: 710 (99.9th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering alignment_1.sam:\n  4,989 pass\n  16 fail\n\nFiltering alignment_2.sam:\n  4,983 pass\n  22 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\nAlignments before filtering: 552\nAlignments after filtering:  9,972\n\nTime to run: 0:00:00.067202\n\n\n\u001b[1;4;93mStarting Polypolish\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\n\u001b[2m    Polypolish is a tool for polishing genome assemblies with short reads.\nUnlike other tools in this category, Polypolish uses SAM files where each read\nhas been aligned to all possible locations (not just a single best location).\nThis allows it to repair errors in repeat regions that other alignment-based\npolishers cannot fix.\u001b[0m\n\nPolypolish version: 0.5.0\n\nInput assembly:\n  input_data\n\nInput short-read alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --fraction_invalid 0.2\n  --fraction_valid 0.5\n  --max_errors 10\n  --min_depth 5\n  not logging debugging information\n\n\n\u001b[1;4;93mLoading assembly\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\ncontig00001 (5,513 bp)\ncontig00002 (3,532 bp)\ncontig00003 (3,227 bp)\ncontig00004 (3,138 bp)\n\n\n\u001b[1;4;93mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\nfiltered_1.sam: 280 alignments from 275 reads\nfiltered_2.sam: 272 alignments from 267 reads\n\nFiltering for high-quality end-to-end alignments:\n  219 alignments kept\n  333 alignments discarded\n\n\n\u001b[1;4;93mPolishing assembly sequences\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\n\u001b[2m    For each position in the assembly, Polypolish determines the read depth\nat that position and collects all aligned bases. It then polishes the assembly\nby looking for positions where the pileup unambiguously supports a different\nsequence than the assembly.\u001b[0m\n\nPolishing contig00001 (5,513 bp):\n  mean read depth: 7.7x\n  170 bp have a depth of zero (96.9164% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00002 (3,532 bp):\n  mean read depth: 3.2x\n  941 bp have a depth of zero (73.3579% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00003 (3,227 bp):\n  mean read depth: 2.2x\n  785 bp have a depth of zero (75.6740% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00004 (3,138 bp):\n  mean read depth: 1.4x\n  1,239 bp have a depth of zero (60.5163% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\n\n\u001b[1;4;93mFinished!\u001b[0m \u001b[2m(2022-09-08 14:23:08)\u001b[0m\nPolished sequence (to stdout):\n  contig00001_polypolish (5,513 bp)\n  contig00002_polypolish (3,532 bp)\n  contig00003_polypolish (3,227 bp)\n  contig00004_polypolish (3,138 bp)\n\nTime to run: 0:00:00.010772\n\n", "stdout": "", "job_messages": [], "dependencies": [], "user_email": "test@bx.psu.edu", "job_metrics": []}, "status": "success"}}, {"id": "functional.test_toolbox.TestForTool_polypolish.test_tool_000005", "has_data": true, "data": {"tool_id": "polypolish", "tool_version": "0.5.0+galaxy0", "test_index": 5, "time_seconds": 22.513530492782593, "inputs": {"input|fasta_file": {"src": "hda", "id": "35b2f24e3cd2a88e"}, "input|raw_data_type|R1_fastq": {"src": "hda", "id": "95a4e892543fdd16"}, "input|raw_data_type|R2_fastq": {"src": "hda", "id": "5200dfb526c5300c"}, "input|raw_data_type|fastq_selector": "paired", "input|raw_data_type|insert_filter|filter_select": "filter", "input|raw_data_type|insert_filter|high": "98.7", "input|raw_data_type|insert_filter|low": "1", "options|debug": false, "options|no_logfile": false}, "job": {"model_class": "Job", "id": "a4d4402402eb735b", "state": "ok", "exit_code": 0, "update_time": "2022-09-08T14:23:34.062123", "create_time": "2022-09-08T14:23:25.603884", "galaxy_version": "22.05", "command_version": "Polypolish v0.5.0", "tool_id": "polypolish", "history_id": "17977ad024d03fef", "external_id": "124173", "command_line": "ln -s '/tmp/tmprjy9g23w/files/0/8/d/dataset_08da37f4-fe1d-4a0c-bbbb-a8f3020b310b.dat' input_data &&  bwa index input_data && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/b/2/9/dataset_b29c4ae8-f823-4ed7-87ca-445964ca715c.dat' > alignment_1.sam && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/4/4/a/dataset_44a1c716-bdf1-47f4-a974-230765398958.dat' > alignment_2.sam && polypolish_insert_filter.py --low '1.0' --high '98.7' --in1 'alignment_1.sam' --in2 'alignment_2.sam' --out1 'filtered_1.sam' --out2 'filtered_2.sam' && polypolish input_data 'filtered_1.sam' 'filtered_2.sam' >  /tmp/tmprjy9g23w/job_working_directory/000/76/outputs/galaxy_dataset_473c9d63-9719-45fe-810a-6c70cdb22ab7.dat", "traceback": null, "params": {"input": "{\"fasta_file\": {\"values\": [{\"id\": 83, \"src\": \"hda\"}]}, \"raw_data_type\": {\"R1_fastq\": {\"values\": [{\"id\": 86, \"src\": \"hda\"}]}, \"R2_fastq\": {\"values\": [{\"id\": 87, \"src\": \"hda\"}]}, \"__current_case__\": 1, \"fastq_selector\": \"paired\", \"insert_filter\": {\"__current_case__\": 0, \"filter_select\": \"filter\", \"high\": \"98.7\", \"low\": \"1.0\"}}}", "options": "{\"debug\": \"false\", \"fraction_invalid\": \"0.2\", \"fraction_valid\": \"0.5\", \"max_errors\": \"10\", \"min_depth\": \"5\", \"no_logfile\": \"false\"}", "chromInfo": "\"/tmp/tmprjy9g23w/galaxy-dev/tool-data/shared/ucsc/chrom/?.len\"", "dbkey": "\"?\"", "__input_ext": "\"input\""}, "inputs": {"fasta_file": {"id": "35b2f24e3cd2a88e", "src": "hda", "uuid": "08da37f4-fe1d-4a0c-bbbb-a8f3020b310b"}, "input|R1_fastq": {"id": "a435b6ffa4eaa489", "src": "hda", "uuid": "b29c4ae8-f823-4ed7-87ca-445964ca715c"}, "input|R2_fastq": {"id": "8f3386efb1aea803", "src": "hda", "uuid": "44a1c716-bdf1-47f4-a974-230765398958"}}, "outputs": {"polished_fasta": {"id": "968b0385cdf32183", "src": "hda", "uuid": "473c9d63-9719-45fe-810a-6c70cdb22ab7"}}, "output_collections": {}, "tool_stdout": "", "tool_stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.021 sec; CPU: 0.007 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.359 CPU sec, 0.359 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/b/2/9/dataset_b29c4ae8-f823-4ed7-87ca-445964ca715c.dat\n[main] Real time: 0.380 sec; CPU: 0.377 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.362 CPU sec, 0.362 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/4/4/a/dataset_44a1c716-bdf1-47f4-a974-230765398958.dat\n[main] Real time: 0.378 sec; CPU: 0.375 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  alignment_1.sam\n  alignment_2.sam\n\nOutput alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --orientation auto\n  --low 1.0\n  --high 98.7\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\nalignment_1.sam: 280 alignments from 275 reads\nalignment_2.sam: 272 alignments from 267 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 176 pairs\nrf: 74 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  30 (1.0th percentile)\nHigh threshold: 629 (98.7th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering alignment_1.sam:\n  4,989 pass\n  16 fail\n\nFiltering alignment_2.sam:\n  4,982 pass\n  23 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\nAlignments before filtering: 552\nAlignments after filtering:  9,971\n\nTime to run: 0:00:00.069129\n\n\n\u001b[1;4;93mStarting Polypolish\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\n\u001b[2m    Polypolish is a tool for polishing genome assemblies with short reads.\nUnlike other tools in this category, Polypolish uses SAM files where each read\nhas been aligned to all possible locations (not just a single best location).\nThis allows it to repair errors in repeat regions that other alignment-based\npolishers cannot fix.\u001b[0m\n\nPolypolish version: 0.5.0\n\nInput assembly:\n  input_data\n\nInput short-read alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --fraction_invalid 0.2\n  --fraction_valid 0.5\n  --max_errors 10\n  --min_depth 5\n  not logging debugging information\n\n\n\u001b[1;4;93mLoading assembly\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\ncontig00001 (5,513 bp)\ncontig00002 (3,532 bp)\ncontig00003 (3,227 bp)\ncontig00004 (3,138 bp)\n\n\n\u001b[1;4;93mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\nfiltered_1.sam: 280 alignments from 275 reads\nfiltered_2.sam: 272 alignments from 267 reads\n\nFiltering for high-quality end-to-end alignments:\n  219 alignments kept\n  333 alignments discarded\n\n\n\u001b[1;4;93mPolishing assembly sequences\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\n\u001b[2m    For each position in the assembly, Polypolish determines the read depth\nat that position and collects all aligned bases. It then polishes the assembly\nby looking for positions where the pileup unambiguously supports a different\nsequence than the assembly.\u001b[0m\n\nPolishing contig00001 (5,513 bp):\n  mean read depth: 7.7x\n  170 bp have a depth of zero (96.9164% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00002 (3,532 bp):\n  mean read depth: 3.2x\n  941 bp have a depth of zero (73.3579% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00003 (3,227 bp):\n  mean read depth: 2.2x\n  785 bp have a depth of zero (75.6740% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00004 (3,138 bp):\n  mean read depth: 1.4x\n  1,239 bp have a depth of zero (60.5163% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\n\n\u001b[1;4;93mFinished!\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\nPolished sequence (to stdout):\n  contig00001_polypolish (5,513 bp)\n  contig00002_polypolish (3,532 bp)\n  contig00003_polypolish (3,227 bp)\n  contig00004_polypolish (3,138 bp)\n\nTime to run: 0:00:00.010178\n\n", "job_stdout": "", "job_stderr": "", "stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.021 sec; CPU: 0.007 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.359 CPU sec, 0.359 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/b/2/9/dataset_b29c4ae8-f823-4ed7-87ca-445964ca715c.dat\n[main] Real time: 0.380 sec; CPU: 0.377 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.362 CPU sec, 0.362 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/4/4/a/dataset_44a1c716-bdf1-47f4-a974-230765398958.dat\n[main] Real time: 0.378 sec; CPU: 0.375 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  alignment_1.sam\n  alignment_2.sam\n\nOutput alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --orientation auto\n  --low 1.0\n  --high 98.7\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\nalignment_1.sam: 280 alignments from 275 reads\nalignment_2.sam: 272 alignments from 267 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 176 pairs\nrf: 74 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  30 (1.0th percentile)\nHigh threshold: 629 (98.7th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering alignment_1.sam:\n  4,989 pass\n  16 fail\n\nFiltering alignment_2.sam:\n  4,982 pass\n  23 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\nAlignments before filtering: 552\nAlignments after filtering:  9,971\n\nTime to run: 0:00:00.069129\n\n\n\u001b[1;4;93mStarting Polypolish\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\n\u001b[2m    Polypolish is a tool for polishing genome assemblies with short reads.\nUnlike other tools in this category, Polypolish uses SAM files where each read\nhas been aligned to all possible locations (not just a single best location).\nThis allows it to repair errors in repeat regions that other alignment-based\npolishers cannot fix.\u001b[0m\n\nPolypolish version: 0.5.0\n\nInput assembly:\n  input_data\n\nInput short-read alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --fraction_invalid 0.2\n  --fraction_valid 0.5\n  --max_errors 10\n  --min_depth 5\n  not logging debugging information\n\n\n\u001b[1;4;93mLoading assembly\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\ncontig00001 (5,513 bp)\ncontig00002 (3,532 bp)\ncontig00003 (3,227 bp)\ncontig00004 (3,138 bp)\n\n\n\u001b[1;4;93mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\nfiltered_1.sam: 280 alignments from 275 reads\nfiltered_2.sam: 272 alignments from 267 reads\n\nFiltering for high-quality end-to-end alignments:\n  219 alignments kept\n  333 alignments discarded\n\n\n\u001b[1;4;93mPolishing assembly sequences\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\n\u001b[2m    For each position in the assembly, Polypolish determines the read depth\nat that position and collects all aligned bases. It then polishes the assembly\nby looking for positions where the pileup unambiguously supports a different\nsequence than the assembly.\u001b[0m\n\nPolishing contig00001 (5,513 bp):\n  mean read depth: 7.7x\n  170 bp have a depth of zero (96.9164% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00002 (3,532 bp):\n  mean read depth: 3.2x\n  941 bp have a depth of zero (73.3579% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00003 (3,227 bp):\n  mean read depth: 2.2x\n  785 bp have a depth of zero (75.6740% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00004 (3,138 bp):\n  mean read depth: 1.4x\n  1,239 bp have a depth of zero (60.5163% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\n\n\u001b[1;4;93mFinished!\u001b[0m \u001b[2m(2022-09-08 14:23:31)\u001b[0m\nPolished sequence (to stdout):\n  contig00001_polypolish (5,513 bp)\n  contig00002_polypolish (3,532 bp)\n  contig00003_polypolish (3,227 bp)\n  contig00004_polypolish (3,138 bp)\n\nTime to run: 0:00:00.010178\n\n", "stdout": "", "job_messages": [], "dependencies": [], "user_email": "test@bx.psu.edu", "job_metrics": []}, "status": "success"}}, {"id": "functional.test_toolbox.TestForTool_polypolish.test_tool_000006", "has_data": true, "data": {"tool_id": "polypolish", "tool_version": "0.5.0+galaxy0", "test_index": 6, "time_seconds": 23.43229103088379, "inputs": {"input|fasta_file": {"src": "hda", "id": "d3131e183e7fac33"}, "input|raw_data_type|R1_fastq": {"src": "hda", "id": "9843544413fa1e7b"}, "input|raw_data_type|R2_fastq": {"src": "hda", "id": "4e49a4426490d675"}, "input|raw_data_type|fastq_selector": "paired", "input|raw_data_type|insert_filter|filter_select": "filter", "input|raw_data_type|insert_filter|high": "96.6", "input|raw_data_type|insert_filter|low": "1.4", "options|debug": false, "options|fraction_invalid": "0.5", "options|fraction_valid": "0.6", "options|max_errors": "8", "options|min_depth": "10", "options|no_logfile": false}, "job": {"model_class": "Job", "id": "a1bcce9ecdd2e452", "state": "ok", "exit_code": 0, "update_time": "2022-09-08T14:23:57.470812", "create_time": "2022-09-08T14:23:49.082819", "galaxy_version": "22.05", "command_version": "Polypolish v0.5.0", "tool_id": "polypolish", "history_id": "aa82843c2e82e9f8", "external_id": "124638", "command_line": "ln -s '/tmp/tmprjy9g23w/files/4/c/9/dataset_4c9e48e9-dedc-479d-8c70-e57c8e325a36.dat' input_data &&  bwa index input_data && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/8/6/7/dataset_867028c9-bf3e-4664-b895-2768c8942dac.dat' > alignment_1.sam && bwa mem -t ${GALAXY_SLOTS:-7} -a input_data '/tmp/tmprjy9g23w/files/c/d/7/dataset_cd739843-f1fd-4582-acc4-7d83d0390c6a.dat' > alignment_2.sam && polypolish_insert_filter.py --low '1.4' --high '96.6' --in1 'alignment_1.sam' --in2 'alignment_2.sam' --out1 'filtered_1.sam' --out2 'filtered_2.sam' && polypolish input_data 'filtered_1.sam' 'filtered_2.sam' >  /tmp/tmprjy9g23w/job_working_directory/000/82/outputs/galaxy_dataset_b2e301e1-8e68-439f-a971-2f4d90825b08.dat", "traceback": null, "params": {"input": "{\"fasta_file\": {\"values\": [{\"id\": 89, \"src\": \"hda\"}]}, \"raw_data_type\": {\"R1_fastq\": {\"values\": [{\"id\": 92, \"src\": \"hda\"}]}, \"R2_fastq\": {\"values\": [{\"id\": 93, \"src\": \"hda\"}]}, \"__current_case__\": 1, \"fastq_selector\": \"paired\", \"insert_filter\": {\"__current_case__\": 0, \"filter_select\": \"filter\", \"high\": \"96.6\", \"low\": \"1.4\"}}}", "options": "{\"debug\": \"false\", \"fraction_invalid\": \"0.5\", \"fraction_valid\": \"0.6\", \"max_errors\": \"8\", \"min_depth\": \"10\", \"no_logfile\": \"false\"}", "chromInfo": "\"/tmp/tmprjy9g23w/galaxy-dev/tool-data/shared/ucsc/chrom/?.len\"", "dbkey": "\"?\"", "__input_ext": "\"input\""}, "inputs": {"fasta_file": {"id": "d3131e183e7fac33", "src": "hda", "uuid": "4c9e48e9-dedc-479d-8c70-e57c8e325a36"}, "input|R1_fastq": {"id": "93a8082090f57b26", "src": "hda", "uuid": "867028c9-bf3e-4664-b895-2768c8942dac"}, "input|R2_fastq": {"id": "35f645ca6f7d64d3", "src": "hda", "uuid": "cd739843-f1fd-4582-acc4-7d83d0390c6a"}}, "outputs": {"polished_fasta": {"id": "aa219d5b8589b50f", "src": "hda", "uuid": "b2e301e1-8e68-439f-a971-2f4d90825b08"}}, "output_collections": {}, "tool_stdout": "", "tool_stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.019 sec; CPU: 0.006 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.365 CPU sec, 0.365 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/8/6/7/dataset_867028c9-bf3e-4664-b895-2768c8942dac.dat\n[main] Real time: 0.385 sec; CPU: 0.380 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.353 CPU sec, 0.353 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/c/d/7/dataset_cd739843-f1fd-4582-acc4-7d83d0390c6a.dat\n[main] Real time: 0.369 sec; CPU: 0.367 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  alignment_1.sam\n  alignment_2.sam\n\nOutput alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --orientation auto\n  --low 1.4\n  --high 96.6\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\nalignment_1.sam: 280 alignments from 275 reads\nalignment_2.sam: 272 alignments from 267 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 176 pairs\nrf: 74 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  31 (1.4th percentile)\nHigh threshold: 582 (96.6th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering alignment_1.sam:\n  4,989 pass\n  16 fail\n\nFiltering alignment_2.sam:\n  4,982 pass\n  23 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\nAlignments before filtering: 552\nAlignments after filtering:  9,971\n\nTime to run: 0:00:00.072781\n\n\n\u001b[1;4;93mStarting Polypolish\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\n\u001b[2m    Polypolish is a tool for polishing genome assemblies with short reads.\nUnlike other tools in this category, Polypolish uses SAM files where each read\nhas been aligned to all possible locations (not just a single best location).\nThis allows it to repair errors in repeat regions that other alignment-based\npolishers cannot fix.\u001b[0m\n\nPolypolish version: 0.5.0\n\nInput assembly:\n  input_data\n\nInput short-read alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --fraction_invalid 0.2\n  --fraction_valid 0.5\n  --max_errors 10\n  --min_depth 5\n  not logging debugging information\n\n\n\u001b[1;4;93mLoading assembly\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\ncontig00001 (5,513 bp)\ncontig00002 (3,532 bp)\ncontig00003 (3,227 bp)\ncontig00004 (3,138 bp)\n\n\n\u001b[1;4;93mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\nfiltered_1.sam: 280 alignments from 275 reads\nfiltered_2.sam: 272 alignments from 267 reads\n\nFiltering for high-quality end-to-end alignments:\n  219 alignments kept\n  333 alignments discarded\n\n\n\u001b[1;4;93mPolishing assembly sequences\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\n\u001b[2m    For each position in the assembly, Polypolish determines the read depth\nat that position and collects all aligned bases. It then polishes the assembly\nby looking for positions where the pileup unambiguously supports a different\nsequence than the assembly.\u001b[0m\n\nPolishing contig00001 (5,513 bp):\n  mean read depth: 7.7x\n  170 bp have a depth of zero (96.9164% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00002 (3,532 bp):\n  mean read depth: 3.2x\n  941 bp have a depth of zero (73.3579% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00003 (3,227 bp):\n  mean read depth: 2.2x\n  785 bp have a depth of zero (75.6740% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00004 (3,138 bp):\n  mean read depth: 1.4x\n  1,239 bp have a depth of zero (60.5163% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\n\n\u001b[1;4;93mFinished!\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\nPolished sequence (to stdout):\n  contig00001_polypolish (5,513 bp)\n  contig00002_polypolish (3,532 bp)\n  contig00003_polypolish (3,227 bp)\n  contig00004_polypolish (3,138 bp)\n\nTime to run: 0:00:00.012935\n\n", "job_stdout": "", "job_stderr": "", "stderr": "[bwa_index] Pack FASTA... 0.00 sec\n[bwa_index] Construct BWT for the packed sequence...\n[bwa_index] 0.00 seconds elapse.\n[bwa_index] Update BWT... 0.00 sec\n[bwa_index] Pack forward-only FASTA... 0.00 sec\n[bwa_index] Construct SA from BWT and Occ... 0.00 sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa index input_data\n[main] Real time: 0.019 sec; CPU: 0.006 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.365 CPU sec, 0.365 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/8/6/7/dataset_867028c9-bf3e-4664-b895-2768c8942dac.dat\n[main] Real time: 0.385 sec; CPU: 0.380 sec\n[M::bwa_idx_load_from_disk] read 0 ALT contigs\n[M::process] read 5000 sequences (1505000 bp)...\n[M::mem_process_seqs] Processed 5000 reads in 0.353 CPU sec, 0.353 real sec\n[main] Version: 0.7.17-r1188\n[main] CMD: bwa mem -t 1 -a input_data /tmp/tmprjy9g23w/files/c/d/7/dataset_cd739843-f1fd-4582-acc4-7d83d0390c6a.dat\n[main] Real time: 0.369 sec; CPU: 0.367 sec\n\n\u001b[93m\u001b[1m\u001b[4mPolypolish insert size alignment filter\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\n\u001b[2m    This script is a pre-processing filter that can be run on SAM alignments\u001b[0m\n\u001b[2mbefore they are used in Polypolish. It looks at each read pair and flags\u001b[0m\n\u001b[2malignments that do not seem to be part of a concordant pair. This can improve\u001b[0m\n\u001b[2mthe accuracy of Polypolish, especially near the edges of repeats.\u001b[0m\n\nInput alignments:\n  alignment_1.sam\n  alignment_2.sam\n\nOutput alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --orientation auto\n  --low 1.4\n  --high 96.6\n\n\n\u001b[93m\u001b[1m\u001b[4mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\nalignment_1.sam: 280 alignments from 275 reads\nalignment_2.sam: 272 alignments from 267 reads\n\n\n\u001b[93m\u001b[1m\u001b[4mFinding insert size thresholds\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\n\u001b[2m    Read pairs with exactly one alignment per read are used to determine the\u001b[0m\n\u001b[2morientation and insert size thresholds for the read set.\u001b[0m\n\nfr: 176 pairs\nrf: 74 pairs\nff: 0 pairs\nrr: 0 pairs\n\nAutomatically determined correct orientation: fr\n\nLow threshold:  31 (1.4th percentile)\nHigh threshold: 582 (96.6th percentile)\n\n\n\u001b[93m\u001b[1m\u001b[4mFiltering SAM files\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\n\u001b[2m    Read alignments that are part of a good pair (correct orientation and\u001b[0m\n\u001b[2minsert size) pass the filter and are written unaltered to the output file. Read\u001b[0m\n\u001b[2malignments which are not part of good pair are written to the output file with\u001b[0m\n\u001b[2ma \"ZP:Z:fail\" tag so Polypolish will not use them.\u001b[0m\n\nFiltering alignment_1.sam:\n  4,989 pass\n  16 fail\n\nFiltering alignment_2.sam:\n  4,982 pass\n  23 fail\n\n\n\u001b[93m\u001b[1m\u001b[4mFinished!\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\nAlignments before filtering: 552\nAlignments after filtering:  9,971\n\nTime to run: 0:00:00.072781\n\n\n\u001b[1;4;93mStarting Polypolish\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\n\u001b[2m    Polypolish is a tool for polishing genome assemblies with short reads.\nUnlike other tools in this category, Polypolish uses SAM files where each read\nhas been aligned to all possible locations (not just a single best location).\nThis allows it to repair errors in repeat regions that other alignment-based\npolishers cannot fix.\u001b[0m\n\nPolypolish version: 0.5.0\n\nInput assembly:\n  input_data\n\nInput short-read alignments:\n  filtered_1.sam\n  filtered_2.sam\n\nSettings:\n  --fraction_invalid 0.2\n  --fraction_valid 0.5\n  --max_errors 10\n  --min_depth 5\n  not logging debugging information\n\n\n\u001b[1;4;93mLoading assembly\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\ncontig00001 (5,513 bp)\ncontig00002 (3,532 bp)\ncontig00003 (3,227 bp)\ncontig00004 (3,138 bp)\n\n\n\u001b[1;4;93mLoading alignments\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\nfiltered_1.sam: 280 alignments from 275 reads\nfiltered_2.sam: 272 alignments from 267 reads\n\nFiltering for high-quality end-to-end alignments:\n  219 alignments kept\n  333 alignments discarded\n\n\n\u001b[1;4;93mPolishing assembly sequences\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\n\u001b[2m    For each position in the assembly, Polypolish determines the read depth\nat that position and collects all aligned bases. It then polishes the assembly\nby looking for positions where the pileup unambiguously supports a different\nsequence than the assembly.\u001b[0m\n\nPolishing contig00001 (5,513 bp):\n  mean read depth: 7.7x\n  170 bp have a depth of zero (96.9164% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00002 (3,532 bp):\n  mean read depth: 3.2x\n  941 bp have a depth of zero (73.3579% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00003 (3,227 bp):\n  mean read depth: 2.2x\n  785 bp have a depth of zero (75.6740% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\nPolishing contig00004 (3,138 bp):\n  mean read depth: 1.4x\n  1,239 bp have a depth of zero (60.5163% coverage)\n  0 positions changed (0.0000% of total positions)\n  estimated pre-polishing sequence accuracy: 100.0000%\n\n\n\u001b[1;4;93mFinished!\u001b[0m \u001b[2m(2022-09-08 14:23:54)\u001b[0m\nPolished sequence (to stdout):\n  contig00001_polypolish (5,513 bp)\n  contig00002_polypolish (3,532 bp)\n  contig00003_polypolish (3,227 bp)\n  contig00004_polypolish (3,138 bp)\n\nTime to run: 0:00:00.012935\n\n", "stdout": "", "job_messages": [], "dependencies": [], "user_email": "test@bx.psu.edu", "job_metrics": []}, "status": "success"}}], "summary": {"num_tests": 7, "num_failures": 0, "num_errors": 0, "num_skips": 0}, "exit_code": 0}